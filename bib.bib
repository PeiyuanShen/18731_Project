@inproceedings{Antoniadis+etal:2020:Java,
  author    = {Antoniadis, Anastasios and Filippakis, Nikos and Krishnan, Paddy and Ramesh, Raghavendra and Allen, Nicholas and Smaragdakis, Yannis},
  title     = {Static Analysis of Java Enterprise Applications: Frameworks and Caches, the Elephants in the Room},
  year      = {2020},
  isbn      = {9781450376136},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3385412.3386026},
  doi       = {10.1145/3385412.3386026},
  booktitle = {Proceedings of the 41st ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages     = {794–807},
  numpages  = {14},
  keywords  = {points-to analysis, static analysis, Java EE},
  location  = {London, UK},
  series    = {PLDI 2020}
}

@article{Bravenboer:2009:Doop,
  author     = {Bravenboer, Martin and Smaragdakis, Yannis},
  title      = {Strictly Declarative Specification of Sophisticated Points-to Analyses},
  year       = {2009},
  issue_date = {October 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {44},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1639949.1640108},
  doi        = {10.1145/1639949.1640108},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {243–262},
  numpages   = {20},
  keywords   = {declarative, DOOP, bdds, datalog, points-to analysis}
}

@inproceedings{Backes+etal:2018:Zelkova,
  author    = {Backes, John and Bolignano, Pauline and Cook, Byron and Dodge, Catherine and Gacek, Andrew and Luckow, Kasper and Rungta, Neha and Tkachuk, Oksana and Varming, Carsten},
  booktitle = {2018 Formal Methods in Computer Aided Design (FMCAD)},
  title     = {Semantic-based Automated Reasoning for AWS Access Policies using SMT},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {1-9},
  doi       = {10.23919/FMCAD.2018.8602994}
}

@misc{spring+security:main,
  author       = {{Spring}},
  title        = {{Spring Security}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {https://spring.io/projects/spring-security}
}

@misc{spring+security:home,
  author       = {{Spring}},
  title        = {{Spring Security}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {https://spring.io/}
}


@misc{spring+security:method,
  author       = {{Baeldung}},
  title        = {{Introduction to Spring Method Security}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {https://www.baeldung.com/spring-security-method-security}
}

@misc{spring+security:expr,
  author       = {{Baeldung}},
  title        = {{Intro to Spring Security Expressions}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {https://www.baeldung.com/spring-security-expressions}
}

@misc{Smaragdakis:DOOP,
  author       = {{Yannis Smaragdakis}},
  title        = {{DOOP}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {http://doop.program-analysis.org/}
}

@misc{GitLab:framework,
  author       = {{GitLab}},
  title        = {{DeclarativePolicy framework}},
  howpublished = {Accessed Feb. 13, 2022 [Online]},
  url          = {http://doop.program-analysis.org/}
}

@inproceedings{10.1145/2048066.2048146,
author = {Son, Sooel and McKinley, Kathryn S. and Shmatikov, Vitaly},
title = {RoleCast: Finding Missing Security Checks When You Do Not Know What Checks Are},
year = {2011},
isbn = {9781450309400},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2048066.2048146},
doi = {10.1145/2048066.2048146},
abstract = {Web applications written in languages such as PHP and JSP are notoriously vulnerable to accidentally omitted authorization checks and other security bugs. Existing techniques that find missing security checks in library and system code assume that (1) security checks can be recognized syntactically and (2) the same pattern of checks applies universally to all programs. These assumptions do not hold for Web applications. Each Web application uses different variables and logic to check the user's permissions. Even within the application, security logic varies based on the user's role, e.g., regular users versus administrators. This paper describes ROLECAST, the first system capable of statically identifying security logic that mediates security-sensitive events (such as database writes) in Web applications, rather than taking a specification of this logic as input. We observe a consistent software engineering pattern-the code that implements distinct user role functionality and its security logic resides in distinct methods and files-and develop a novel algorithm for discovering this pattern in Web applications. Our algorithm partitions the set of file contexts (a coarsening of calling contexts) on which security-sensitive events are control dependent into roles. Roles are based on common functionality and security logic. ROLECAST identifies security-critical variables and applies rolespecific variable consistency analysis to find missing security checks. ROLECAST discovered 13 previously unreported, remotely exploitable vulnerabilities in 11 substantial PHP and JSP applications, with only 3 false positives.This paper demonstrates that (1) accurate inference of application- and role-specific security logic improves the security of Web applications without specifications, and (2) static analysis can discover security logic automatically by exploiting distinctive software engineering features.},
booktitle = {Proceedings of the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {1069–1084},
numpages = {16},
keywords = {static analysis, access control, interprocedural analysis, PHP, user roles, security checks, security, JSP},
location = {Portland, Oregon, USA},
series = {OOPSLA '11}
}

@inproceedings{inproceedings,
author = {Ujcich, Benjamin and Jero, Samuel and Skowyra, Richard and Gomez, Steven and Bates, Adam and Sanders, William and Okhravi, Hamed},
year = {2020},
month = {01},
pages = {},
title = {Automated Discovery of Cross-Plane Event-Based Vulnerabilities in Software-Defined Networking},
doi = {10.14722/ndss.2020.24080}
}

@ARTICLE{6994333,  author={Kreutz, Diego and Ramos, Fernando M. V. and Veríssimo, Paulo Esteves and Rothenberg, Christian Esteve and Azodolmolky, Siamak and Uhlig, Steve},  journal={Proceedings of the IEEE},   title={Software-Defined Networking: A Comprehensive Survey},   year={2015},  volume={103},  number={1},  pages={14-76},  doi={10.1109/JPROC.2014.2371999}}

@article{10.1145/1543135.1542486,
author = {Tripp, Omer and Pistoia, Marco and Fink, Stephen J. and Sridharan, Manu and Weisman, Omri},
title = {TAJ: Effective Taint Analysis of Web Applications},
year = {2009},
issue_date = {June 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/1543135.1542486},
doi = {10.1145/1543135.1542486},
abstract = {Taint analysis, a form of information-flow analysis, establishes whether values from untrusted methods and parameters may flow into security-sensitive operations. Taint analysis can detect many common vulnerabilities in Web applications, and so has attracted much attention from both the research community and industry. However, most static taint-analysis tools do not address critical requirements for an industrial-strength tool. Specifically, an industrial-strength tool must scale to large industrial Web applications, model essential Web-application code artifacts, and generate consumable reports for a wide range of attack vectors.We have designed and implemented a static Taint Analysis for Java (TAJ) that meets the requirements of industry-level applications. TAJ can analyze applications of virtually any size, as it employs a set of techniques designed to produce useful answers given limited time and space. TAJ addresses a wide variety of attack vectors, with techniques to handle reflective calls, flow through containers, nested taint, and issues in generating useful reports. This paper provides a description of the algorithms comprising TAJ, evaluates TAJ against production-level benchmarks, and compares it with alternative solutions.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {87–97},
numpages = {11},
keywords = {security, program analysis, web application, java, taint analysis, static analysis, slicing}
}

@inproceedings{10.1145/1542476.1542486,
author = {Tripp, Omer and Pistoia, Marco and Fink, Stephen J. and Sridharan, Manu and Weisman, Omri},
title = {TAJ: Effective Taint Analysis of Web Applications},
year = {2009},
isbn = {9781605583921},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1542476.1542486},
doi = {10.1145/1542476.1542486},
abstract = {Taint analysis, a form of information-flow analysis, establishes whether values from untrusted methods and parameters may flow into security-sensitive operations. Taint analysis can detect many common vulnerabilities in Web applications, and so has attracted much attention from both the research community and industry. However, most static taint-analysis tools do not address critical requirements for an industrial-strength tool. Specifically, an industrial-strength tool must scale to large industrial Web applications, model essential Web-application code artifacts, and generate consumable reports for a wide range of attack vectors.We have designed and implemented a static Taint Analysis for Java (TAJ) that meets the requirements of industry-level applications. TAJ can analyze applications of virtually any size, as it employs a set of techniques designed to produce useful answers given limited time and space. TAJ addresses a wide variety of attack vectors, with techniques to handle reflective calls, flow through containers, nested taint, and issues in generating useful reports. This paper provides a description of the algorithms comprising TAJ, evaluates TAJ against production-level benchmarks, and compares it with alternative solutions.},
booktitle = {Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {87–97},
numpages = {11},
keywords = {static analysis, slicing, web application, taint analysis, program analysis, security, java},
location = {Dublin, Ireland},
series = {PLDI '09}
}

@inproceedings{10.1145/2048066.2048145,
author = {Sridharan, Manu and Artzi, Shay and Pistoia, Marco and Guarnieri, Salvatore and Tripp, Omer and Berg, Ryan},
title = {F4F: Taint Analysis of Framework-Based Web Applications},
year = {2011},
isbn = {9781450309400},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2048066.2048145},
doi = {10.1145/2048066.2048145},
abstract = {This paper presents F4F (Framework For Frameworks), a system for effective taint analysis of framework-based web applications. Most modern web applications utilize one or more web frameworks, which provide useful abstractions for common functionality. Due to extensive use of reflective language constructs in framework implementations, existing static taint analyses are often ineffective when applied to framework-based applications. While previous work has included ad hoc support for certain framework constructs, adding support for a large number of frameworks in this manner does not scale from an engineering standpoint.F4F employs an initial analysis pass in which both application code and configuration files are processed to generate a specification of framework-related behaviors. A taint analysis engine can leverage these specifications to perform a much deeper, more precise analysis of framework-based applications. Our specification language has only a small number of simple but powerful constructs, easing analysis engine integration. With this architecture, new frameworks can be handled with no changes to the core analysis engine, yielding significant engineering benefits.We implemented specification generators for several web frameworks and added F4F support to a state-of-the-art taint-analysis engine. In an experimental evaluation, the taint analysis enhanced with F4F discovered 525 new issues across nine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Furthermore, manual inspection of a subset of the new issues showed that many were exploitable or reflected bad security practice.},
booktitle = {Proceedings of the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications},
pages = {1053–1068},
numpages = {16},
keywords = {security, frameworks, taint analysis},
location = {Portland, Oregon, USA},
series = {OOPSLA '11}
}

@article{10.1145/2076021.2048145,
author = {Sridharan, Manu and Artzi, Shay and Pistoia, Marco and Guarnieri, Salvatore and Tripp, Omer and Berg, Ryan},
title = {F4F: Taint Analysis of Framework-Based Web Applications},
year = {2011},
issue_date = {October 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/2076021.2048145},
doi = {10.1145/2076021.2048145},
abstract = {This paper presents F4F (Framework For Frameworks), a system for effective taint analysis of framework-based web applications. Most modern web applications utilize one or more web frameworks, which provide useful abstractions for common functionality. Due to extensive use of reflective language constructs in framework implementations, existing static taint analyses are often ineffective when applied to framework-based applications. While previous work has included ad hoc support for certain framework constructs, adding support for a large number of frameworks in this manner does not scale from an engineering standpoint.F4F employs an initial analysis pass in which both application code and configuration files are processed to generate a specification of framework-related behaviors. A taint analysis engine can leverage these specifications to perform a much deeper, more precise analysis of framework-based applications. Our specification language has only a small number of simple but powerful constructs, easing analysis engine integration. With this architecture, new frameworks can be handled with no changes to the core analysis engine, yielding significant engineering benefits.We implemented specification generators for several web frameworks and added F4F support to a state-of-the-art taint-analysis engine. In an experimental evaluation, the taint analysis enhanced with F4F discovered 525 new issues across nine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Furthermore, manual inspection of a subset of the new issues showed that many were exploitable or reflected bad security practice.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {1053–1068},
numpages = {16},
keywords = {frameworks, taint analysis, security}
}

@article{10.1145/2666356.2594299,
author = {Arzt, Steven and Rasthofer, Siegfried and Fritz, Christian and Bodden, Eric and Bartel, Alexandre and Klein, Jacques and Le Traon, Yves and Octeau, Damien and McDaniel, Patrick},
title = {FlowDroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps},
year = {2014},
issue_date = {June 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2666356.2594299},
doi = {10.1145/2666356.2594299},
abstract = {Today's smartphones are a ubiquitous source of private and confidential data. At the same time, smartphone users are plagued by carelessly programmed apps that leak important data by accident, and by malicious apps that exploit their given privileges to copy such data intentionally. While existing static taint-analysis approaches have the potential of detecting such data leaks ahead of time, all approaches for Android use a number of coarse-grain approximations that can yield high numbers of missed leaks and false alarms.In this work we thus present FlowDroid, a novel and highly precise static taint analysis for Android applications. A precise model of Android's lifecycle allows the analysis to properly handle callbacks invoked by the Android framework, while context, flow, field and object-sensitivity allows the analysis to reduce the number of false alarms. Novel on-demand algorithms help FlowDroid maintain high efficiency and precision at the same time.We also propose DroidBench, an open test suite for evaluating the effectiveness and accuracy of taint-analysis tools specifically for Android apps. As we show through a set of experiments using SecuriBench Micro, DroidBench, and a set of well-known Android test applications, FlowDroid finds a very high fraction of data leaks while keeping the rate of false positives low. On DroidBench, FlowDroid achieves 93% recall and 86% precision, greatly outperforming the commercial tools IBM AppScan Source and Fortify SCA. FlowDroid successfully finds leaks in a subset of 500 apps from Google Play and about 1,000 malware apps from the VirusShare project.},
journal = {SIGPLAN Not.},
month = {jun},
pages = {259–269},
numpages = {11}
}

@inproceedings{10.1145/2594291.2594299,
author = {Arzt, Steven and Rasthofer, Siegfried and Fritz, Christian and Bodden, Eric and Bartel, Alexandre and Klein, Jacques and Le Traon, Yves and Octeau, Damien and McDaniel, Patrick},
title = {FlowDroid: Precise Context, Flow, Field, Object-Sensitive and Lifecycle-Aware Taint Analysis for Android Apps},
year = {2014},
isbn = {9781450327848},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2594291.2594299},
doi = {10.1145/2594291.2594299},
abstract = {Today's smartphones are a ubiquitous source of private and confidential data. At the same time, smartphone users are plagued by carelessly programmed apps that leak important data by accident, and by malicious apps that exploit their given privileges to copy such data intentionally. While existing static taint-analysis approaches have the potential of detecting such data leaks ahead of time, all approaches for Android use a number of coarse-grain approximations that can yield high numbers of missed leaks and false alarms.In this work we thus present FlowDroid, a novel and highly precise static taint analysis for Android applications. A precise model of Android's lifecycle allows the analysis to properly handle callbacks invoked by the Android framework, while context, flow, field and object-sensitivity allows the analysis to reduce the number of false alarms. Novel on-demand algorithms help FlowDroid maintain high efficiency and precision at the same time.We also propose DroidBench, an open test suite for evaluating the effectiveness and accuracy of taint-analysis tools specifically for Android apps. As we show through a set of experiments using SecuriBench Micro, DroidBench, and a set of well-known Android test applications, FlowDroid finds a very high fraction of data leaks while keeping the rate of false positives low. On DroidBench, FlowDroid achieves 93\% recall and 86\% precision, greatly outperforming the commercial tools IBM AppScan Source and Fortify SCA. FlowDroid successfully finds leaks in a subset of 500 apps from Google Play and about 1,000 malware apps from the VirusShare project.},
booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {259–269},
numpages = {11},
location = {Edinburgh, United Kingdom},
series = {PLDI '14}
}

@INPROCEEDINGS{6394931,  author={Yang, Zhemin and Yang, Min},  booktitle={2012 Third World Congress on Software Engineering},   title={LeakMiner: Detect Information Leakage on Android with Static Taint Analysis},   year={2012},  volume={},  number={},  pages={101-104},  doi={10.1109/WCSE.2012.26}}

@InProceedings{10.1007/978-3-030-63461-2_7,
author="Mues, Malte
and Schallau, Till
and Howar, Falk",
editor="Dongol, Brijesh
and Troubitsyna, Elena",
title="Jaint: A Framework for User-Defined Dynamic Taint-Analyses Based on Dynamic Symbolic Execution of Java Programs",
booktitle="Integrated Formal Methods",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="123--140",
abstract="We present Jaint, a generic security analysis for Java Web-applications that combines concolic execution and dynamic taint analysis in a modular way. Jaint executes user-defined taint analyses that are formally specified in a domain-specific language for expressing taint-flow analyses. We demonstrate how dynamic taint analysis can be integrated into JDart, a dynamic symbolic execution engine for the Java virtual machine in Java PathFinder. The integration of the two methods is modular in the sense that it traces taint independently of symbolic annotations. Therefore, Jaint is capable of sanitizing taint information (if specified by a taint analysis) and using multi-colored taint for running multiple taint analyses in parallel. We design a domain-specific language that enables users to define specific taint-based security analyses for Java Web-applications. Specifications in this domain-specific language serve as a basis for the automated generation of corresponding taint injectors, sanitization points and taint-flow monitors that implement taint analyses in Jaint. We demonstrate the generality and effectiveness of the approach by analyzing the OWASP benchmark set, using generated taint analyses for all 11 classes of CVEs in the benchmark set.",
isbn="978-3-030-63461-2"
}

@article{10.1145/3133926,
author = {Grech, Neville and Smaragdakis, Yannis},
title = {P/Taint: Unified Points-to and Taint Analysis},
year = {2017},
issue_date = {October 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {OOPSLA},
url = {https://doi.org/10.1145/3133926},
doi = {10.1145/3133926},
abstract = {Static information-flow analysis (especially taint-analysis) is a key technique in software security, computing where sensitive or untrusted data can propagate in a program. Points-to analysis is a fundamental static program analysis, computing what abstract objects a program expression may point to. In this work, we propose a deep unification of information-flow and points-to analysis. We observe that information-flow analysis is not a mere high-level client of points-to information, but it is indeed identical to points-to analysis on artificial abstract objects that represent different information sources. The very same algorithm can compute, simultaneously, two interlinked but separate results (points-to and information-flow values) with changes only to its initial conditions. The benefits of such a unification are manifold. We can use existing points-to analysis implementations, with virtually no modification (only minor additions of extra logic for sanitization) to compute information flow concepts, such as value tainting. The algorithmic enhancements of points-to analysis (e.g., different flavors of context sensitivity) can be applied transparently to information-flow analysis. Heavy engineering work on points-to analysis (e.g., handling of the reflection API for Java) applies to information-flow analysis without extra effort. We demonstrate the benefits in a realistic implementation that leverages the Doop points-to analysis framework (including its context-sensitivity and reflection analysis features) to provide an information-flow analysis with excellent precision (over 91%) and recall (over 99%) for standard Java information-flow benchmarks. The analysis comfortably scales to large, real-world Android applications, analyzing the Facebook Messenger app with more than 55K classes in under 7 hours.},
journal = {Proc. ACM Program. Lang.},
month = {oct},
articleno = {102},
numpages = {28},
keywords = {Pointer Analysis, Taint Analysis, Android}
}

@inproceedings{10.1145/2635868.2635878,
author = {Lerch, Johannes and Hermann, Ben and Bodden, Eric and Mezini, Mira},
title = {FlowTwist: Efficient Context-Sensitive inside-out Taint Analysis for Large Codebases},
year = {2014},
isbn = {9781450330565},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2635868.2635878},
doi = {10.1145/2635868.2635878},
abstract = { Over the past years, widely used platforms such as the Java Class Library have been under constant attack through vulnerabilities that involve a combination of two taint-analysis problems: an integrity problem allowing attackers to trigger sensitive operations within the platform, and a confidentiality problem allowing the attacker to retrieve sensitive information or pointers from the results of those operations. While existing static taint analyses are good at solving either of those problems, we show that they scale prohibitively badly when being applied to situations that require the exploitation of both an integrity and confidentiality problem in combination. The main problem is the huge attack surface of libraries such as the Java Class Library, which exposes thousands of methods potentially controllable by an attacker. In this work we thus present FlowTwist, a novel taint-analysis approach that works inside-out, i.e., tracks data flows from potentially vulnerable calls to the outer level of the API which the attacker might control. This inside-out analysis requires a careful, context-sensitive coordination of both a backward and a forward taint analysis. In this work, we expose a design of the analysis approach based on the IFDS algorithm, and explain several extensions to IFDS that enable not only this coordination but also a helpful reporting of error situations to security analysts. Experiments with the Java Class Library show that, while a simple forward taint-analysis approach does not scale even with much machine power, FlowTwist's algorithm is able to fully analyze the library within 10 minutes. },
booktitle = {Proceedings of the 22nd ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {98–108},
numpages = {11},
keywords = {confused deputy, IFDS, Taint analysis},
location = {Hong Kong, China},
series = {FSE 2014}
}

@inproceedings{10.1145/3236024.3236029,
author = {Pauck, Felix and Bodden, Eric and Wehrheim, Heike},
title = {Do Android Taint Analysis Tools Keep Their Promises?},
year = {2018},
isbn = {9781450355735},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3236024.3236029},
doi = {10.1145/3236024.3236029},
abstract = {In recent years, researchers have developed a number of tools to conduct taint analysis of Android applications. While all the respective papers aim at providing a thorough empirical evaluation, comparability is hindered by varying or unclear evaluation targets. Sometimes, the apps used for evaluation are not precisely described. In other cases, authors use an established benchmark but cover it only partially. In yet other cases, the evaluations differ in terms of the data leaks searched for, or lack a ground truth to compare against. All those limitations make it impossible to truly compare the tools based on those published evaluations.  We thus present ReproDroid, a framework allowing the accurate comparison of Android taint analysis tools. ReproDroid supports researchers in inferring the ground truth for data leaks in apps, in automatically applying tools to benchmarks, and in evaluating the obtained results. We use ReproDroid to comparatively evaluate on equal grounds the six prominent taint analysis tools Amandroid, DIALDroid, DidFail, DroidSafe, FlowDroid and IccTA. The results are largely positive although four tools violate some promises concerning features and accuracy. Finally, we contribute to the area of unbiased benchmarking with a new and improved version of the open test suite DroidBench.},
booktitle = {Proceedings of the 2018 26th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {331–341},
numpages = {11},
keywords = {Empirical Studies, Tools, Benchmarks, Reproducibility, Android Taint Analysis},
location = {Lake Buena Vista, FL, USA},
series = {ESEC/FSE 2018}
}